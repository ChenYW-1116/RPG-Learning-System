<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="pageTitle">âš”ï¸ IELTS æŒ‘æˆ°è€…ç«¶æŠ€å ´ - Challenger Arena</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Orbitron:wght@400;500;700;900&display=swap"
        rel="stylesheet">
    <script src="DevScribeRPG.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0F0F1A 0%, #1A1A2E 50%, #16213E 100%);
            min-height: 100vh;
            color: #E2E8F0;
        }

        .title-glow {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, #EF4444, #F97316, #FBBF24, #EF4444);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleShimmer 3s linear infinite;
        }

        @keyframes titleShimmer {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 300% 50%;
            }
        }

        /* Boss Card */
        .boss-card {
            background: linear-gradient(145deg, rgba(127, 29, 29, 0.4), rgba(30, 41, 59, 0.8));
            border: 2px solid #EF4444;
            border-radius: 16px;
            position: relative;
            overflow: visible;
            /* Changed from hidden to show tooltips */
        }

        .boss-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 0%, rgba(239, 68, 68, 0.1), transparent 70%);
            border-radius: 14px;
            /* Maintain rounded corners for the glow */
            pointer-events: none;
        }

        .boss-card.defeated {
            border-color: #10B981;
            background: linear-gradient(145deg, rgba(6, 78, 59, 0.4), rgba(30, 41, 59, 0.8));
        }

        .boss-card.defeated::before {
            background: radial-gradient(circle at 50% 0%, rgba(16, 185, 129, 0.1), transparent 70%);
        }

        /* HP Bar */
        .hp-bar-container {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 8px;
            height: 24px;
            overflow: hidden;
            position: relative;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #EF4444, #F97316);
            transition: width 1s ease;
            position: relative;
        }

        .hp-bar::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: hpShine 2s infinite;
        }

        @keyframes hpShine {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* Battle Log */
        .battle-log {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.7), rgba(15, 23, 42, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .log-victory {
            border-left: 3px solid #10B981;
        }

        .log-defeat {
            border-left: 3px solid #EF4444;
        }

        .log-neutral {
            border-left: 3px solid #6366F1;
        }

        /* Stats Grid */
        .stat-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.6), rgba(15, 23, 42, 0.8));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
        }

        /* Challenge Button */
        .challenge-btn {
            background: linear-gradient(135deg, #EF4444, #DC2626);
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
        }

        .challenge-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 30px rgba(239, 68, 68, 0.6);
        }

        /* Essay Input */
        .essay-textarea {
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            color: #E2E8F0;
            font-size: 16px;
            line-height: 1.8;
            resize: vertical;
        }

        .essay-textarea:focus {
            outline: none;
            border-color: #6366F1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(145deg, #1E293B, #0F172A);
            border: 2px solid #6366F1;
            border-radius: 20px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Animations */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .animate-pulse {
            animation: pulse 2s infinite;
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* Victory Effect */
        .victory-burst {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 999;
            background: radial-gradient(circle, rgba(16, 185, 129, 0.3), transparent 70%);
            animation: burst 1s ease-out forwards;
        }

        @keyframes burst {
            0% {
                opacity: 1;
                transform: scale(0.5);
            }

            100% {
                opacity: 0;
                transform: scale(2);
            }
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1A1A2E;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6366F1, #8B5CF6);
            border-radius: 3px;
        }

        /* Tooltip */
        .custom-tooltip {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .custom-tooltip .tooltip-box {
            visibility: hidden;
            width: 240px;
            background-color: #0F172A;
            color: #F8FAFC;
            text-align: left;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 10000;
            /* Extremely high z-index */
            bottom: 130%;
            left: 0;
            opacity: 0;
            transition: all 0.2s ease;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.8), 0 10px 10px -5px rgba(0, 0, 0, 0.5);
            font-size: 0.8rem;
            line-height: 1.4;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }

        .custom-tooltip:hover .tooltip-box {
            visibility: visible;
            opacity: 1;
            bottom: 120%;
        }

        .custom-tooltip .info-icon {
            background: rgba(148, 163, 184, 0.1);
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: #94A3B8;
            font-size: 0.7rem;
            cursor: help;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Boss Defeated Overlay */
        .boss-defeated-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .boss-defeated-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .boss-explosion {
            font-size: 15rem;
            animation: explosion 1s ease-out forwards;
        }

        @keyframes explosion {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 0;
                filter: blur(10px);
            }
        }

        .boss-defeated-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(to right, #FCD34D, #F59E0B, #D97706);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0;
            transform: translateY(20px);
            animation: textFadeIn 0.8s 0.8s forwards ease-out;
        }

        @keyframes textFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body class="p-4 md:p-8">
    <!-- èªè¨€åˆ‡æ›æŒ‰éˆ• -->
    <div class="fixed bottom-6 right-6 z-50">
        <button id="langToggleBtn" type="button" onclick="toggleLanguage()"
            class="bg-slate-700/80 hover:bg-slate-600 backdrop-blur-md text-gray-300 text-sm py-2 px-4 rounded-full border border-slate-600 shadow-2xl transition flex items-center">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" />
            </svg>
            <span id="langBtnText">EN</span>
        </button>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="modal-overlay hidden">
        <div class="text-center">
            <div class="text-6xl mb-4 animate-pulse">âš”ï¸</div>
            <div class="text-xl font-semibold" id="loading-text" data-i18n="loadingTitle">AI æ­£åœ¨è©•ä¼°ä½ çš„æˆ°é¬¥è¡¨ç¾...</div>
            <div class="text-gray-400 mt-2" id="loading-subtext" data-i18n="loadingSubtitle">è«‹ç¨å€™</div>
        </div>
    </div>

    <!-- Boss Defeated Overlay -->
    <div id="boss-defeated-overlay" class="boss-defeated-overlay">
        <div class="boss-explosion">ğŸ’¥</div>
        <div class="boss-defeated-text" data-i18n="bossDefeatedTitle">BOSS DEFEATED</div>
        <div class="text-2xl text-white mt-4 opacity-0 animate-[textFadeIn_0.8s_1.5s_forwards]" id="defeated-boss-name">
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal" class="modal-overlay hidden">
        <div class="modal-content text-center">
            <div id="result-icon" class="text-8xl mb-4">âš”ï¸</div>
            <h2 id="result-title" class="text-3xl font-bold mb-4" data-i18n="resultTitle">æˆ°é¬¥çµæœ</h2>
            <div id="result-details" class="text-left space-y-4"></div>
            <button onclick="closeResultModal()"
                class="mt-6 px-8 py-3 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-semibold transition"
                data-i18n="confirmBtn">
                ç¢ºèª
            </button>
        </div>
    </div>

    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="title-glow text-4xl md:text-5xl font-black mb-2 tracking-wider" data-i18n="mainTitle">
                âš”ï¸ CHALLENGER ARENA
            </h1>
            <p class="text-gray-400 text-lg" data-i18n="subTitle">IELTS æŒ‘æˆ°è€…ç«¶æŠ€å ´ â€” æ“Šæ•—ä½ çš„å¼±é» Boss</p>
            <a href="rpg-hub.html"
                class="inline-flex items-center mt-4 px-4 py-2 bg-slate-800/50 hover:bg-slate-700/50 border border-slate-600 rounded-full text-indigo-400 hover:text-indigo-300 text-sm transition"
                data-i18n="backLink">
                â† Back to Quest Empire
            </a>
        </header>

        <!-- RPG Status -->
        <div id="rpg-status" class="mb-8"></div>

        <!-- Backend Status Display -->
        <section
            class="mb-8 p-3 bg-slate-800/30 rounded-xl border border-slate-700 flex justify-center items-center gap-2">
            <span class="text-xs font-medium text-gray-400" data-i18n="backendSystem">ç³»çµ±æ ¸å¿ƒ: Python Backend (RCA
                Engine)</span>
            <span class="text-gray-600">|</span>
            <span id="backend-status" class="text-xs text-gray-500 transition-colors duration-300"
                data-i18n="backendStatus">æ­£åœ¨åµæ¸¬å¾Œç«¯ç‹€æ…‹...</span>
        </section>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left: Boss Display -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <span data-i18n="bossSectionTitle">ğŸ‰ ç•¶å‰ Boss (ä½ çš„ç“¶é ¸)</span>
                </h2>
                <div id="boss-container" class="space-y-4">
                    <div class="boss-card p-6">
                        <div class="text-center text-gray-400 py-8">
                            <div class="text-5xl mb-4">â“</div>
                            <p data-i18n="bossEmptyState">å°šæœªåˆ†æã€‚æäº¤ä½ çš„ç¬¬ä¸€ç¯‡ä½œæ–‡ä¾†ç™¼ç¾ä½ çš„ Bossï¼</p>
                        </div>
                    </div>
                </div>

                <!-- Stats -->
                <h2 class="text-xl font-bold mt-8 mb-4 flex items-center gap-2">
                    <span data-i18n="statsTitle">ğŸ“Š æˆ°ç¸¾çµ±è¨ˆ</span>
                </h2>
                <div class="grid grid-cols-2 gap-3">
                    <div class="stat-card">
                        <div class="stat-value text-green-400" id="stat-victories">0</div>
                        <div class="text-xs text-gray-400" data-i18n="statVictories">ç¸½å‹åˆ©</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-red-400" id="stat-defeats">0</div>
                        <div class="text-xs text-gray-400" data-i18n="statDefeats">ç¸½å¤±æ•—</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-yellow-400" id="stat-essays">0</div>
                        <div class="text-xs text-gray-400" data-i18n="statEssays">ç¸½ä½œæ–‡æ•¸</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-indigo-400" id="stat-avg-band">-</div>
                        <div class="text-xs text-gray-400" data-i18n="statAvgBand">å¹³å‡ Band</div>
                    </div>
                </div>
            </div>

            <!-- Right: Essay Input & Battle Log -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Essay Submission -->
                <section>
                    <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                        <span data-i18n="essayInputTitle">ğŸ“ æäº¤æŒ‘æˆ°ä½œæ–‡</span>
                    </h2>
                    <div class="bg-slate-800/30 rounded-xl p-6 border border-slate-700">
                        <textarea id="essay-input" class="essay-textarea w-full h-64 p-4 mb-4"
                            data-i18n-placeholder="essayPlaceholder"
                            placeholder="åœ¨æ­¤è²¼ä¸Šä½ çš„ IELTS Task 1 ä½œæ–‡...&#10;&#10;AI æœƒè‡ªå‹•åˆ†æä¸¦èˆ‡ä½ ä¹‹å‰çš„è¡¨ç¾æ¯”è¼ƒï¼Œåˆ¤å®šé€™æ¬¡æŒ‘æˆ°æ˜¯å¦æˆåŠŸæ“Šæ•—äº†ä½ çš„å¼±é» Bossï¼"></textarea>

                        <div class="flex flex-wrap items-center gap-4">
                            <button id="challenge-btn" class="challenge-btn text-white flex items-center gap-2"
                                data-i18n="challengeBtn">
                                âš”ï¸ ç™¼èµ·æŒ‘æˆ°ï¼
                            </button>
                            <div class="text-sm text-gray-400">
                                <span id="word-count">0</span> <span data-i18n="wordCountLabel">å­—</span>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Battle Log -->
                <section>
                    <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                        <span data-i18n="logSectionTitle">ğŸ“œ æˆ°é¬¥æ—¥èªŒ</span>
                    </h2>
                    <div id="battle-log" class="battle-log">
                        <div class="text-center text-gray-500 py-8" data-i18n="logEmptyState">
                            é‚„æ²’æœ‰ä»»ä½•æˆ°é¬¥è¨˜éŒ„ã€‚é–‹å§‹ä½ çš„ç¬¬ä¸€æ¬¡æŒ‘æˆ°å§ï¼
                        </div>
                    </div>
                </section>

                <!-- RCA Chart Display -->
                <section id="chart-section" class="hidden">
                    <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                        <span data-i18n="chartSectionTitle">ğŸ“Š RCA åˆ†æåœ–è¡¨</span>
                        <span class="text-xs font-normal text-gray-400" data-i18n="chartBackendNote">(ç”± Python
                            å¾Œç«¯ç”Ÿæˆ)</span>
                    </h2>

                    <div id="charts-legacy" class="hidden">
                        <img id="rca-chart" src="" alt="RCA Analysis Chart"
                            class="w-full rounded-lg border border-slate-600">
                    </div>

                    <div id="charts-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Radar Chart -->
                        <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700 flex flex-col items-center">
                            <h3 class="text-sm font-bold text-gray-400 mb-2 w-full text-left">ğŸ“Š æŠ€èƒ½åˆ†ä½ˆ (Skill Balance)
                            </h3>
                            <div class="w-full aspect-square max-h-[300px]">
                                <canvas id="radarChart"></canvas>
                            </div>
                        </div>

                        <!-- Trend Chart -->
                        <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700 flex flex-col items-center">
                            <h3 class="text-sm font-bold text-gray-400 mb-2 w-full text-left">ğŸ“ˆ é€²æ­¥è¶¨å‹¢ (Progress Trend)
                            </h3>
                            <div class="w-full aspect-video max-h-[300px]">
                                <canvas id="trendChart"></canvas>
                            </div>
                        </div>

                        <!-- RCA Bar Chart -->
                        <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700 col-span-1 md:col-span-2">
                            <h3 class="text-sm font-bold text-gray-400 mb-2">âš ï¸ é—œéµç“¶é ¸ (Top Improvement Priorities)</h3>
                            <div class="w-full h-[300px]">
                                <canvas id="rcaChart"></canvas>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- AI Recommendations -->
                <section id="recommendations-section" class="hidden">
                    <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                        <span data-i18n="recSectionTitle">ğŸ’¡ AI å­¸ç¿’å»ºè­°</span>
                    </h2>
                    <div id="recommendations-content"
                        class="bg-slate-800/30 rounded-xl p-6 border border-slate-700 prose prose-invert max-w-none text-sm leading-relaxed">
                    </div>
                </section>
            </div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ï¿½ INTERNATIONALIZATION (i18n)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        window.i18n = {
            currentLang: 'zh',
            translations: {
                zh: {
                    pageTitle: "âš”ï¸ IELTS æŒ‘æˆ°è€…ç«¶æŠ€å ´ - Challenger Arena",
                    loadingTitle: "AI æ­£åœ¨è©•ä¼°ä½ çš„æˆ°é¬¥è¡¨ç¾...",
                    loadingSubtitle: "è«‹ç¨å€™",
                    resultTitle: "æˆ°é¬¥çµæœ",
                    confirmBtn: "ç¢ºèª",
                    mainTitle: "âš”ï¸ CHALLENGER ARENA",
                    subTitle: "IELTS æŒ‘æˆ°è€…ç«¶æŠ€å ´ â€” æ“Šæ•—ä½ çš„å¼±é» Boss",
                    backLink: "â† è¿”å› Quest Empire",
                    backendSystem: "ç³»çµ±æ ¸å¿ƒ: Python Backend (RCA Engine)",
                    backendStatus: "æ­£åœ¨åµæ¸¬å¾Œç«¯ç‹€æ…‹...",
                    bossSectionTitle: "ğŸ‰ ç•¶å‰ Boss (ä½ çš„ç“¶é ¸)",
                    bossEmptyState: "å°šæœªåˆ†æã€‚æäº¤ä½ çš„ç¬¬ä¸€ç¯‡ä½œæ–‡ä¾†ç™¼ç¾ä½ çš„ Bossï¼",
                    statsTitle: "ğŸ“Š æˆ°ç¸¾çµ±è¨ˆ",
                    statVictories: "ç¸½å‹åˆ©",
                    statDefeats: "ç¸½å¤±æ•—",
                    statEssays: "ç¸½ä½œæ–‡æ•¸",
                    statAvgBand: "å¹³å‡ Band",
                    bossSkillMastery: "æŠ€èƒ½ç†Ÿç·´åº¦",
                    essayInputTitle: "ğŸ“ æäº¤æŒ‘æˆ°ä½œæ–‡",
                    essayPlaceholder: "åœ¨æ­¤è²¼ä¸Šä½ çš„ IELTS Task 1 ä½œæ–‡...\\n\\nAI æœƒè‡ªå‹•åˆ†æä¸¦èˆ‡ä½ ä¹‹å‰çš„è¡¨ç¾æ¯”è¼ƒï¼Œåˆ¤å®šé€™æ¬¡æŒ‘æˆ°æ˜¯å¦æˆåŠŸæ“Šæ•—äº†ä½ çš„å¼±é» Bossï¼",
                    challengeBtn: "âš”ï¸ ç™¼èµ·æŒ‘æˆ°ï¼",
                    wordCountLabel: "å­—",
                    logSectionTitle: "ğŸ“œ æˆ°é¬¥æ—¥èªŒ",
                    logEmptyState: "é‚„æ²’æœ‰ä»»ä½•æˆ°é¬¥è¨˜éŒ„ã€‚é–‹å§‹ä½ çš„ç¬¬ä¸€æ¬¡æŒ‘æˆ°å§ï¼",
                    chartSectionTitle: "ğŸ“Š RCA åˆ†æåœ–è¡¨",
                    chartBackendNote: "(ç”± Python å¾Œç«¯ç”Ÿæˆ)",
                    chartPlaceholder: "ä½¿ç”¨ã€Œå¾Œç«¯æ¨¡å¼ã€æäº¤ä½œæ–‡å¾Œï¼Œåœ–è¡¨å°‡é¡¯ç¤ºåœ¨æ­¤è™•",
                    recSectionTitle: "ğŸ’¡ AI å­¸ç¿’å»ºè­°",

                    // JS Dynamic Strings
                    alertNoApiKey: "è«‹å…ˆè¼¸å…¥ Gemini API Keyï¼",
                    alertShortEssay: "è«‹è¼¸å…¥è‡³å°‘ 50 å­—çš„ä½œæ–‡ï¼",
                    analysisFailed: "åˆ†æå¤±æ•—ï¼š",
                    confirmClear: "âš ï¸ ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰ä½œæ–‡ç´€éŒ„å—ï¼Ÿ\\n\\né€™å°‡åˆªé™¤ï¼š\\nâ€¢ æ‰€æœ‰æ­·å²ä½œæ–‡\\nâ€¢ æˆ°é¬¥æ—¥èªŒ\\nâ€¢ Boss è³‡æ–™\\nâ€¢ çµ±è¨ˆæ•¸æ“š\\n\\næ­¤æ“ä½œç„¡æ³•å¾©åŸï¼",
                    clearedSuccess: "âœ… æ‰€æœ‰ç´€éŒ„å·²æ¸…ç©ºï¼",
                    bossDefeated: "å·²æ“Šæ•—ï¼",
                    bossWeakness: "å¼±é»ç­‰ç´š",
                    bossThreat: "å¨è„…åº¦",
                    bossThreatDesc: "æ­¤ Boss å°ä½ æ•´é«”åˆ†æ•¸çš„å½±éŸ¿ç¨‹åº¦ (åŸºæ–¼ Random Forest é‡è¦æ€§æŒ‡æ¨™)ã€‚æ•¸å€¼è¶Šé«˜ï¼Œæ“Šæ•—å®ƒå°æå‡ Band åˆ†æ•¸è¶Šæœ‰å¹«åŠ©ï¼",
                    bossDefeatedTitle: "BOSS æ“Šæ®ºï¼",
                    bossDefeatedMsg: "ä½ æ“Šæ•—äº†é•·æœŸéœ¸æ¦œçš„å¼±é» Bossï¼",
                    challengeSuccess: "æŒ‘æˆ°æˆåŠŸï¼",
                    challengeFail: "æŒ‘æˆ°å¤±æ•—",
                    victoryTitle: "æŒ‘æˆ°æˆåŠŸï¼<br><span class='text-green-400'>ä½ æ“Šæ•—äº†å¼±é»ï¼</span>",

                    // Backend & Modal
                    alertBackendOffline: "ç™¼èµ·å¤±æ•—ï¼šå¾Œç«¯æœªé€£ç·šï¼\\n\\nè«‹ç¢ºä¿å·²åœ¨çµ‚ç«¯æ©ŸåŸ·è¡Œï¼š\\npython arena_api.py",
                    alertRunPython: "è«‹åŸ·è¡Œ python arena_api.py",
                    loadingBackend: "æ­£åœ¨èª¿ç”¨ Python å¾Œç«¯é€²è¡Œå®Œæ•´ RCA åˆ†æ...",
                    loadingSubtextBackend: "åŒ…å« Random Forest æ©Ÿå™¨å­¸ç¿’åˆ†æå’Œåœ–è¡¨ç”Ÿæˆ",
                    backendConnected: "å¾Œç«¯ç‹€æ…‹: âœ… å·²é€£æ¥",
                    backendDisconnected: "å¾Œç«¯ç‹€æ…‹: âŒ æœªé€£æ¥ (è«‹å•Ÿå‹• arena_api.py)",
                    modalBand: "Band {band}",
                    modalImprovements: "ğŸ“ˆ é€²æ­¥é …ç›®",
                    modalRegressions: "ğŸ“‰ éœ€åŠ å¼·",
                    firstSubmission: "é¦–æ¬¡æäº¤ï¼",
                    first_submission: "é¦–æ¬¡æäº¤ï¼",
                    firstsubmission: "é¦–æ¬¡æäº¤ï¼",
                    failTitle: "æŒ‘æˆ°å¤±æ•—<br><span class='text-red-400'>ç¹¼çºŒåŠªåŠ›ï¼</span>",
                    firstBattleTitle: "é¦–æ¬¡æŒ‘æˆ°å®Œæˆï¼<br><span class='text-yellow-400'>Band {band}</span>",

                    // Metrics
                    ta_overview_clarity: 'TA: æ¦‚è¿°æ¸…æ™°åº¦',
                    ta_overview_clarity_desc: 'è©•ä¼°æ˜¯å¦åŒ…å«æ¸…æ¥šçš„æ¦‚è¿°ï¼Œç¸½çµæµç¨‹çš„ä¸»è¦æ€§è³ªï¼ˆå¦‚ï¼šè¼¸å…¥åˆ°è¼¸å‡ºçš„è½‰è®Šï¼‰ã€‚',
                    ta_step_coverage: 'TA: æ­¥é©Ÿæ¶µè“‹åº¦',
                    ta_step_coverage_desc: 'è©•ä¼°æ˜¯å¦åŒ…å«äº†æµç¨‹åœ–ä¸­æ‰€æœ‰çš„ä¸»è¦æ­¥é©Ÿèˆ‡éšæ®µï¼Œæ²’æœ‰éºæ¼é—œéµè³‡è¨Šã€‚',
                    ta_logic_accuracy: 'TA: é‚è¼¯æº–ç¢ºæ€§',
                    ta_logic_accuracy_desc: 'è©•ä¼°æµç¨‹èµ°å‘ã€ç®­é ­åŠè¼¸å…¥/è¼¸å‡ºå¾ªç’°æ˜¯å¦è§£è®€æ­£ç¢ºï¼Œç„¡é‚è¼¯èª¤è®€ã€‚',
                    ta_data_accuracy: 'TA: é‚è¼¯æº–ç¢ºæ€§', // ç‚ºäº†èˆŠæ•¸æ“šç›¸å®¹æ€§
                    ta_data_accuracy_desc: 'è©•ä¼°å°æµç¨‹åœ–æ•¸æ“šèˆ‡é‚è¼¯çš„è§£è®€æ˜¯å¦æº–ç¢ºã€‚',
                    cc_sequencing_markers: 'CC: é †åºæ¨™è¨˜',
                    cc_sequencing_markers_desc: 'è©•ä¼°æ˜¯å¦æœ‰æ•ˆä½¿ç”¨æ™‚é–“é †åºè©ï¼ˆå¦‚ï¼šFirst, Next, Then, Finallyï¼‰ã€‚',
                    cc_referencing: 'CC: æŒ‡ä»£é€£æ¥',
                    cc_referencing_desc: 'è©•ä¼°ä»£åè©èˆ‡æŒ‡ä»£è©çš„ä½¿ç”¨ï¼Œä»¥é€£çµæƒ³æ³•ä¸¦é¿å…å–®èª¿é‡è¤‡ã€‚',
                    cc_paragraphing: 'CC: æ®µè½é‚è¼¯',
                    cc_paragraphing_desc: 'è©•ä¼°æ®µè½åˆ‡åˆ†æ˜¯å¦é‚è¼¯åˆç†ï¼ˆå¦‚ï¼šæŒ‰æµç¨‹éšæ®µåˆ†æ®µï¼‰ã€‚',
                    lr_process_verbs: 'LR: æµç¨‹å‹•è©',
                    lr_process_verbs_desc: 'è©•ä¼°æè¿°å‹•ä½œæ™‚æ‰€ç”¨å‹•è©çš„ç²¾æº–åº¦èˆ‡å¤šæ¨£æ€§ï¼ˆå¦‚ï¼šç£¨ç¢ã€éæ¿¾ã€è¼¸é€ï¼‰ã€‚',
                    lr_topic_nouns: 'LR: ä¸»é¡Œè©å½™',
                    lr_topic_nouns_desc: 'è©•ä¼°æè¿°æµç¨‹åœ–ä¸­è¨­å‚™ã€ç‰©è³ªæˆ–å°ˆæœ‰åè©çš„æº–ç¢ºåº¦ã€‚',
                    lr_paraphrasing: 'LR: æ”¹å¯«èƒ½åŠ›',
                    lr_paraphrasing_desc: 'è©•ä¼°é‡æ–°è¡¨é”é¡Œç›®è¦æ±‚çš„èƒ½åŠ›ï¼Œé¿å…ç›´æ¥ç…§æŠ„é¡Œç›®æ–‡å­—ã€‚',
                    lr_conciseness: 'LR: ç²¾ç°¡åº¦',
                    lr_conciseness_desc: 'è©•ä¼°é£è©ç”¨å­—æ˜¯å¦ç²¾ç…‰ï¼Œé¿å…å†—é•·æˆ–ä¸å¿…è¦çš„ä¿®é£¾ã€‚',
                    gra_passive_voice: 'GRA: è¢«å‹•èªæ…‹',
                    gra_passive_voice_desc: 'è©•ä¼°æè¿°æµç¨‹æ­¥é©Ÿæ™‚ï¼Œè¢«å‹•èªæ…‹ä½¿ç”¨çš„æº–ç¢ºæ€§èˆ‡å°ˆæ¥­åº¦ã€‚',
                    gra_complex_structures: 'GRA: å¥å‹å¤šæ¨£æ€§',
                    gra_complex_structures_desc: 'è©•ä¼°è¤‡åˆå¥ï¼ˆå¦‚ï¼šå¾å¥ã€åˆ†è©çµæ§‹ï¼‰çš„ä½¿ç”¨ï¼Œä½¿æ•˜è¿°æ›´å°ˆæ¥­ã€‚',
                    gra_error_free_density: 'GRA: ç„¡éŒ¯èª¤ç‡',
                    gra_error_free_density_desc: 'è©•ä¼°å¥å­åœ¨æ–‡æ³•èˆ‡æ‹¼å¯«ä¸Šçš„æ­£ç¢ºç‡ã€‚',

                    // RPG Ranks
                    rpgRank1: 'æ–°æ‰‹æŒ‘æˆ°è€…',
                    rpgRank2: 'è¦‹ç¿’å†’éšªå®¶',
                    rpgRank3: 'æ¢ç´¢è€…',
                    rpgRank4: 'æŒ‘æˆ°é”äºº',
                    rpgRank5: 'ç²¾è‹±æˆ°å£«',
                    rpgRank6: 'å°ˆå®¶å¼•å°è€…',
                    rpgRank7: 'å¤§å¸«å‰µé€ è€…',
                    rpgRank8: 'å®—å¸«ç…‰é‡‘å¸«',
                    rpgRank9: 'å‚³å¥‡ç· é€ è€…',
                    rpgRank10: 'å¸åœ‹é ˜è¢–',
                    rpgXpNeeded: 'é‚„éœ€ {xp} XP å‡ç´š',

                    // Notifications
                    notifyChallengeSuccess: 'ğŸ† æŒ‘æˆ°æˆåŠŸï¼',
                    notifyChallengeCompleted: 'âš”ï¸ æŒ‘æˆ°å®Œæˆ',
                    notifyLevelUp: 'ğŸ‰ æ­å–œå‡ç´šï¼',
                    notifyLevelTitle: 'é”åˆ° Lv.{level} {title}',

                    // Chart Specific
                    radarLabel: 'æŠ€èƒ½åˆ†ä½ˆ',
                    trendLabel: 'é€²æ­¥è¶¨å‹¢',
                    trendAxisY: 'åˆ†æ•¸ (Band)',
                    rcaLabel: 'é—œéµç“¶é ¸',
                    rcaAxisX: 'ç“¶é ¸åˆ†æ•¸ (è¶Šå·¦è¶Šå¥½)',
                    prevImpact: 'ä¸Šæ¬¡å½±éŸ¿',
                    currImpact: 'æœ¬æ¬¡å½±éŸ¿',
                    improvedBy: 'é€²æ­¥äº† {val}',
                    worsenedBy: 'é€€æ­¥äº† {val}',
                    scoreLabel: 'åˆ†æ•¸',
                    prevLabel: 'ä¸Šæ¬¡',

                    // RPG Engine Localization
                    errToolNotFound: "æ‰¾ä¸åˆ°æ­¤å·¥å…·",
                    errPluginNotFound: "æ‰¾ä¸åˆ°æ•ˆæœæ’ä»¶",
                    errAlreadyOwned: "ä½ å·²ç¶“æ“æœ‰æ­¤é …ç›®",
                    errInsufficientTokens: "ä»£å¹£ä¸è¶³ï¼éœ€è¦ {cost} ä»£å¹£ï¼Œä½ åªæœ‰ {balance} ä»£å¹£",
                    errNotUnlockedPlugin: "ä½ é‚„æ²’æœ‰è§£é–æ­¤æ•ˆæœ",
                    errAlreadyActivePlugin: "æ­¤æ•ˆæœå·²ç¶“å•Ÿç”¨",
                    errMaxActivePlugins: "æœ€å¤šåŒæ™‚å•Ÿç”¨ 3 å€‹æ•ˆæœ",
                    errNotActivePlugin: "æ­¤æ•ˆæœæœªå•Ÿç”¨",
                    errMinLengthName: "åç¨±è‡³å°‘éœ€è¦ 2 å€‹å­—å…ƒ",
                    errMinLengthDesc: "æè¿°è‡³å°‘éœ€è¦ 10 å€‹å­—å…ƒ",
                    errTokenRange: "ä»£å¹£åƒ¹æ ¼éœ€åœ¨ 10-500 ä¹‹é–“",
                    errInvalidFileName: "è«‹æä¾›æœ‰æ•ˆçš„ HTML æª”æ¡ˆåç¨±",
                    errInvalidCategory: "è«‹é¸æ“‡æœ‰æ•ˆçš„åˆ†é¡",
                    errNotCompleted: "åªèƒ½å°å·²å®Œæˆçš„æŒ‘æˆ°æ’°å¯«æª¢è¨",
                    errAlreadyReflected: "æ­¤æŒ‘æˆ°å·²æœ‰æª¢è¨æ–‡ç« ",
                    errMinLengthReflection: "æª¢è¨æ–‡ç« è‡³å°‘éœ€è¦ 50 å€‹å­—å…ƒ",

                    notifyEarnedXP: "ç²å¾— {xp} XP",
                    notifyLevelUpTitle: "ç­‰ç´šæå‡ï¼",
                    notifyLevelUpMsg: "æ­å–œå‡ç´šè‡³ Lv.{level} {title}",
                    notifyAchievementUnlocked: "æˆå°±è§£é–",
                    notifyToolSaleTitle: "å·¥å…·è²©å”®æˆåŠŸï¼",
                    notifyToolSaleMsg: "+{reward} ğŸ’° å‰µä½œè€…å›é¥‹",
                    rpgGainXP: "ç²å¾—ç¶“é©—å€¼",
                    rpgContrib: "å…¬æœƒè²¢ç»ï¼šæ¨é€æª”æ¡ˆ",
                    rpgArenaWin: "ç«¶æŠ€å ´å‹åˆ©",
                },
                en: {
                    pageTitle: "âš”ï¸ IELTS Challenger Arena",
                    loadingTitle: "AI is evaluating your battle performance...",
                    loadingSubtitle: "Please wait",
                    resultTitle: "Battle Result",
                    confirmBtn: "Confirm",
                    mainTitle: "âš”ï¸ CHALLENGER ARENA",
                    subTitle: "IELTS Challenger Arena â€” Defeat your Weakness Boss",
                    backLink: "â† Back to Quest Empire",
                    backendSystem: "System Core: Python Backend (RCA Engine)",
                    backendStatus: "Detecting backend status...",
                    bossSectionTitle: "Current Boss (Your Bottleneck)",
                    confirmReset: "âš ï¸ Are you sure you want to reset all progress? This cannot be undone!",
                    battleResult: "Battle Result",
                    victory: "Victory",
                    defeat: "Defeat",
                    bossEmptyState: "Not analyzed yet. Submit your first essay to reveal your Boss!",
                    statsTitle: "ğŸ“Š Battle Stats",
                    statVictories: "Victories",
                    statDefeats: "Defeats",
                    statEssays: "Total Essays",
                    statAvgBand: "Avg Band",
                    bossSkillMastery: "Skill Mastery",
                    essayInputTitle: "ğŸ“ Submit Challenge Essay",
                    essayPlaceholder: "Paste your IELTS Task 1 essay here...\\n\\nAI will automatically analyze and compare it with your past performance to determine if you defeated your Weakness Boss!",
                    challengeBtn: "âš”ï¸ Challenge Start!",
                    wordCountLabel: "words",
                    logSectionTitle: "ğŸ“œ Battle Log",
                    logEmptyState: "No battle records yet. Start your first challenge!",
                    chartSectionTitle: "ğŸ“Š RCA Analysis Chart",
                    chartBackendNote: "(Generated by Python Backend)",
                    chartPlaceholder: "Chart will appear here after submitting via 'Backend Mode'",
                    recSectionTitle: "ğŸ’¡ AI Recommendations",

                    // JS Dynamic Strings
                    alertNoApiKey: "Please enter Gemini API Key first!",
                    alertShortEssay: "Please enter at least 50 words!",
                    analysisFailed: "Analysis Failed: ",
                    confirmClear: "âš ï¸ Are you sure you want to clear all records?\\n\\nThis will delete:\\nâ€¢ All history\\nâ€¢ Battle logs\\nâ€¢ Boss data\\nâ€¢ Stats\\n\\nThis cannot be undone!",
                    clearedSuccess: "âœ… All records cleared!",
                    bossDefeated: "Defeated!",
                    bossWeakness: "Weakness Level",
                    bossThreat: "Threat Level",
                    bossThreatDesc: "How much this Boss impacts your overall score (based on Random Forest Importance). Higher threat means defeating it yields greater Band score gains!",
                    bossDefeatedTitle: "BOSS DEFEATED!",
                    bossDefeatedMsg: "You defeated a major weakness Boss!",
                    challengeSuccess: "Victory!",
                    challengeFail: "Defeat",
                    victoryTitle: "Victory!<br><span class='text-green-400'>You defeated your weakness!</span>",

                    // Backend & Modal
                    alertBackendOffline: "Launch Failed: Backend offline!\\n\\nPlease ensure you ran:\\npython arena_api.py",
                    alertRunPython: "Please run python arena_api.py",
                    loadingBackend: "Calling Python Backend for full RCA analysis...",
                    loadingSubtextBackend: "Includes Random Forest ML analysis and chart generation",
                    backendConnected: "Backend Status: âœ… Connected",
                    backendDisconnected: "Backend Status: âŒ Disconnected (Start arena_api.py)",
                    modalBand: "Band {band}",
                    modalImprovements: "ğŸ“ˆ Improvements",
                    modalRegressions: "ğŸ“‰ Needs Work",
                    firstSubmission: "First Submission!",
                    first_submission: "First Submission!",
                    firstsubmission: "First Submission!",
                    failTitle: "Defeat<br><span class='text-red-400'>Keep trying!</span>",
                    firstBattleTitle: "First Challenge Complete!<br><span class='text-yellow-400'>Band {band}</span>",

                    // Metrics
                    ta_overview_clarity: 'TA: Overview Clarity',
                    ta_overview_clarity_desc: 'Evaluates if there is a clear summary of the main nature/trend of the process.',
                    ta_step_coverage: 'TA: Step Coverage',
                    ta_step_coverage_desc: 'Evaluates if all major stages/steps are included without missing critical info.',
                    ta_logic_accuracy: 'TA: Logic Accuracy',
                    ta_logic_accuracy_desc: 'Evaluates if the process flow, arrows, and interpretation are logically correct.',
                    ta_data_accuracy: 'TA: Logic Accuracy', // Compatibility for old records
                    ta_data_accuracy_desc: 'Evaluates the accurate interpretation of diagram logic and sequence.',
                    cc_sequencing_markers: 'CC: Sequencing Markers',
                    cc_sequencing_markers_desc: 'Evaluates effective use of time sequencers (First, Next, Then, Finally).',
                    cc_referencing: 'CC: Referencing',
                    cc_referencing_desc: 'Evaluates use of pronouns/referencing to link ideas and avoid repetition.',
                    cc_paragraphing: 'CC: Paragraph Logic',
                    cc_paragraphing_desc: 'Evaluates if body paragraphs are split logically (e.g., by process phase).',
                    lr_process_verbs: 'LR: Process Verbs',
                    lr_process_verbs_desc: 'Evaluates the variety and precision of verbs describing actions (e.g., ground, filtered).',
                    lr_topic_nouns: 'LR: Topic Nouns',
                    lr_topic_nouns_desc: 'Evaluates accuracy of technical nouns describing equipment/substances.',
                    lr_paraphrasing: 'LR: Paraphrasing',
                    lr_paraphrasing_desc: 'Evaluates ability to rephrase prompt words instead of copying directly.',
                    lr_conciseness: 'LR: Conciseness',
                    lr_conciseness_desc: 'Evaluates precision and avoidance of wordy or unnecessary phrases.',
                    gra_passive_voice: 'GRA: Passive Voice',
                    gra_passive_voice_desc: 'Evaluates appropriate use of passive voice for object-focused process steps.',
                    gra_complex_structures: 'GRA: Complex Structures',
                    gra_complex_structures_desc: 'Evaluates use of complex syntax like relative clauses or time clauses.',
                    gra_error_free_density: 'GRA: Error-Free Density',
                    gra_error_free_density_desc: 'Evaluates the frequency of perfectly correct sentences.',

                    // RPG Ranks
                    rpgRank1: 'Novice Challenger',
                    rpgRank2: 'Apprentice Adventurer',
                    rpgRank3: 'Explorer',
                    rpgRank4: 'Challenge Master',
                    rpgRank5: 'Elite Warrior',
                    rpgRank6: 'Expert Guide',
                    rpgRank7: 'Master Creator',
                    rpgRank8: 'Grandmaster Alchemist',
                    rpgRank9: 'Legendary Founder',
                    rpgRank10: 'Empire Leader',
                    rpgXpNeeded: 'Need {xp} XP to level up',

                    // Notifications
                    notifyChallengeSuccess: 'ğŸ† Challenge Successful!',
                    notifyChallengeCompleted: 'âš”ï¸ Challenge Completed',
                    notifyLevelUp: 'ğŸ‰ Level Up!',
                    notifyLevelTitle: 'Reached Lv.{level} {title}',

                    // Chart Specific
                    radarLabel: 'Skill Balance',
                    trendLabel: 'Progress Trend',
                    trendAxisY: 'Band Score',
                    rcaLabel: 'Top Improvement Priorities',
                    rcaAxisX: 'Bottleneck Score (Left is Better)',
                    prevImpact: 'Previous Impact',
                    currImpact: 'Current Impact',
                    improvedBy: 'Improved by {val}',
                    worsenedBy: 'Worsened by {val}',
                    scoreLabel: 'Score',
                    prevLabel: 'Prev',

                    // RPG Engine Localization
                    errToolNotFound: "Tool not found",
                    errPluginNotFound: "Plugin not found",
                    errAlreadyOwned: "You already own this item",
                    errInsufficientTokens: "Insufficient tokens! Need {cost}, you have {balance}",
                    errNotUnlockedPlugin: "You haven't unlocked this effect yet",
                    errAlreadyActivePlugin: "This effect is already active",
                    errMaxActivePlugins: "Maximum 3 active effects allowed",
                    errNotActivePlugin: "This effect is not active",
                    errMinLengthName: "Name must be at least 2 characters",
                    errMinLengthDesc: "Description must be at least 10 characters",
                    errTokenRange: "Token cost must be between 10 and 500",
                    errInvalidFileName: "Please provide a valid HTML filename",
                    errInvalidCategory: "Please select a valid category",
                    errNotCompleted: "Can only write reflections for completed challenges",
                    errAlreadyReflected: "This challenge already has a reflection",
                    errMinLengthReflection: "Reflection must be at least 50 characters",

                    notifyEarnedXP: "Earned {xp} XP",
                    notifyLevelUpTitle: "Level Up!",
                    notifyLevelUpMsg: "Congratulations! Reached Lv.{level} {title}",
                    notifyAchievementUnlocked: "Achievement Unlocked",
                    notifyToolSaleTitle: "Tool Sold Successfully!",
                    notifyToolSaleMsg: "+{reward} ğŸ’° Creator Reward",
                    rpgGainXP: "Gained Experience",
                    rpgContrib: "Guild Contribution: Push Files",
                    rpgArenaWin: "Arena Victory",
                }
            },

            t: function (key, params = {}) {
                let text = this.translations[this.currentLang][key] || key;
                for (const [k, v] of Object.entries(params)) {
                    text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), v);
                }
                return text;
            },

            setLanguage: function (lang) {
                this.currentLang = lang;
                localStorage.setItem('ielts_arena_lang', lang);
                updateUI(); // Re-render UI first
                this.applyTranslations(); // Then apply translations to all content including dynamic
                checkBackendHealth(); // Refresh backend status text

                // Re-render charts and recommendations from last analysis if available
                if (gameState.lastAnalysis) {
                    if (gameState.lastAnalysis.chart_data) renderCharts(gameState.lastAnalysis.chart_data);
                    if (gameState.lastAnalysis.recommendations) renderAnalysisResult(gameState.lastAnalysis);
                }
            },

            loadSavedLanguage: function () {
                const savedLang = localStorage.getItem('ielts_arena_lang');
                if (savedLang && this.translations[savedLang]) {
                    this.currentLang = savedLang;
                }
            },

            applyTranslations: function () {
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (key) el.innerHTML = this.t(key);
                });

                document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                    const key = el.getAttribute('data-i18n-placeholder');
                    if (key) el.placeholder = this.t(key);
                });

                const btnText = document.getElementById('langBtnText');
                if (btnText) {
                    btnText.innerText = this.currentLang === 'zh' ? 'EN' : 'ä¸­æ–‡';
                }

                document.documentElement.lang = this.currentLang === 'zh' ? 'zh-TW' : 'en';
            }
        };

        window.toggleLanguage = function () {
            const newLang = window.i18n.currentLang === 'zh' ? 'en' : 'zh';
            window.i18n.setLanguage(newLang);
        };

        // Initialize i18n
        window.i18n.loadSavedLanguage();
        window.addEventListener('DOMContentLoaded', () => {
            window.i18n.applyTranslations();
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ® CHALLENGER ARENA ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const STORAGE_KEY = 'ielts_challenger_data';
        const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';

        // IELTS Task 1 è©•åˆ†æŒ‡æ¨™
        const METRICS = {
            ta_overview_clarity: 'ta_overview_clarity',
            ta_step_coverage: 'ta_step_coverage',
            ta_logic_accuracy: 'ta_logic_accuracy',
            cc_sequencing_markers: 'cc_sequencing_markers',
            cc_referencing: 'cc_referencing',
            cc_paragraphing: 'cc_paragraphing',
            lr_process_verbs: 'lr_process_verbs',
            lr_topic_nouns: 'lr_topic_nouns',
            lr_paraphrasing: 'lr_paraphrasing',
            lr_conciseness: 'lr_conciseness',
            gra_passive_voice: 'gra_passive_voice',
            gra_complex_structures: 'gra_complex_structures',
            gra_error_free_density: 'gra_error_free_density'
        };

        // éŠæˆ²ç‹€æ…‹
        let gameState = loadGameState();
        let apiKey = localStorage.getItem('gemini_api_key') || '';

        function loadGameState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) return JSON.parse(saved);
            } catch (e) { console.error(e); }
            return {
                essays: [],
                battleLog: [],
                victories: 0,
                defeats: 0,
                currentBosses: [],
                bossDefeated: {}
            };
        }

        function saveGameState() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
        }

        function clearAllData() {
            if (confirm(window.i18n.t('confirmClear'))) {
                localStorage.removeItem(STORAGE_KEY);
                gameState = loadGameState();
                updateUI();
                alert(window.i18n.t('clearedSuccess'));
                console.log('[Arena] All data cleared');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¤– AI SCORING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function getAIScores(essayText) {
            if (!apiKey) {
                alert(window.i18n.t('alertNoApiKey'));
                throw new Error('No API Key');
            }

            const systemPrompt = `You are an expert IELTS Writing Examiner specializing in Task 1 Process Diagrams.
Evaluate the essay and return ONLY a JSON object with scores 0.0-1.0 (0.9 = Band 9).

Required metrics:
- ta_overview_clarity, ta_step_coverage, ta_data_accuracy
- cc_sequencing_markers, cc_referencing, cc_paragraphing  
- lr_process_verbs, lr_topic_nouns, lr_paraphrasing, lr_conciseness
- gra_passive_voice, gra_complex_structures, gra_error_free_density
- overall_band (0.0-9.0)

Return ONLY raw JSON like: {"ta_overview_clarity": 0.7, ... , "overall_band": 6.5}
Do NOT use markdown code blocks.`;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: `Evaluate this IELTS Task 1 essay:\n\n${essayText}` }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] }
                })
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text || '';

            // Clean and parse JSON
            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').replace(/<think>[\s\S]*?<\/think>/g, '').trim();
            return JSON.parse(cleanText);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ‰ BOSS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function calculateBosses(essays) {
            if (essays.length < 1) return [];

            // 1. Priority: Use results from the latest ML analysis (the "Smart Bosses")
            if (gameState.lastAnalysis && gameState.lastAnalysis.chart_data && gameState.lastAnalysis.chart_data.rca) {
                const rcaItems = [...gameState.lastAnalysis.chart_data.rca];
                // Sort by Bottleneck Index (same as the chart)
                rcaItems.sort((a, b) => b.Bottleneck_Index - a.Bottleneck_Index);

                return rcaItems.slice(0, 3).map(item => ({
                    id: item.Metric,
                    name: item.Metric, // Store the metric key as 'name' to use for translation lookup
                    hp: Math.round(item.Bottleneck_Index * 1000), // Scaled Bottleneck Score as HP
                    avgScore: item.Avg_Score,
                    defeated: gameState.bossDefeated[item.Metric] || false,
                    isSmartBoss: true
                }));
            }

            // 2. Fallback: Simple weakness logic (lowest scores)
            const avgScores = {};
            // Assuming METRICS is defined elsewhere or use keys from existing essays
            const metricKeys = essays[0]?.scores ? Object.keys(essays[0].scores).filter(k => k !== 'overall_band') : [];

            metricKeys.forEach(metric => {
                const values = essays.map(e => e.scores[metric]).filter(v => v !== undefined);
                avgScores[metric] = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
            });

            return metricKeys
                .map(metric => ({
                    id: metric,
                    name: METRICS[metric],
                    hp: Math.round((1 - avgScores[metric]) * 100),
                    avgScore: avgScores[metric],
                    defeated: gameState.bossDefeated[metric] || false,
                    isSmartBoss: false
                }))
                .sort((a, b) => b.hp - a.hp)
                .slice(0, 3);
        }

        function renderBosses() {
            const container = document.getElementById('boss-container');
            const bosses = gameState.currentBosses;

            if (bosses.length === 0) {
                container.innerHTML = `
                    <div class="boss-card p-6">
                        <div class="text-center text-gray-400 py-8">
                            <div class="text-5xl mb-4">â“</div>
                            <p>${window.i18n.t('bossEmptyState')}</p>
                        </div>
                    </div>`;
                return;
            }

            const bossIcons = ['ğŸ‰', 'ğŸ‘¹', 'ğŸ¦¹'];
            container.innerHTML = bosses.map((boss, i) => `
                <div class="boss-card ${boss.defeated ? 'defeated' : ''} p-5">
                    <div class="flex items-center gap-4 mb-3">
                        <span class="text-4xl">${boss.defeated ? 'ğŸ’€' : bossIcons[i]}</span>
                        <div class="flex-1">
                            <div class="custom-tooltip" onclick="alert(window.i18n.t(normalizeMetricKey('${boss.name}') + '_desc'))">
                                <span class="font-bold text-lg ${boss.defeated ? 'text-green-400 line-through' : 'text-red-400'} cursor-pointer">
                                    ${window.i18n.t(normalizeMetricKey(boss.name))}
                                </span>
                                <span class="info-icon">â“˜</span>
                                <div class="tooltip-box">
                                    ${window.i18n.t(normalizeMetricKey(boss.name) + '_desc')}
                                </div>
                            </div>
                            <!-- Threat Level Display -->
                            <div class="flex items-center gap-2 mt-1">
                                <span class="text-xs text-orange-400 font-bold flex items-center gap-1" title="${window.i18n.t('bossThreatDesc')}">
                                    ğŸ›¡ï¸ ${window.i18n.t('bossThreat')}: ${boss.hp}
                                </span>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="text-sm ${boss.avgScore > 0.7 ? 'text-green-400' : boss.avgScore > 0.5 ? 'text-yellow-400' : 'text-red-400'}">
                                ${window.i18n.t('bossSkillMastery')}: ${(boss.avgScore * 100).toFixed(0)}%
                            </div>
                        </div>
                    </div>
                    <!-- HP Bar (Visual Scale: Max 100 for high visibility) -->
                    <div class="hp-bar-container relative group cursor-help">
                        <div class="hp-bar ${boss.hp > 80 ? 'bg-red-600' : boss.hp > 50 ? 'bg-orange-500' : 'bg-yellow-500'}" 
                             style="width: ${Math.min(100, (boss.hp / 100) * 100)}%"></div>
                        <div class="absolute top-0 right-0 text-[10px] text-gray-500 pr-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            Visual Max: 100
                        </div>
                    </div>
                    <div class="flex justify-between mt-2 text-xs text-gray-500">
                        <span>HP: ${boss.hp} <span class="text-gray-600">/ 100 (Max)</span></span>
                        <span>Avg: ${(boss.avgScore).toFixed(2)}</span>
                    </div>
                </div>
            `).join('');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš”ï¸ BATTLE SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function startChallenge() {
            const essayText = document.getElementById('essay-input').value.trim();
            if (!essayText || essayText.length < 50) {
                alert(window.i18n.t('alertShortEssay'));
                return;
            }

            showLoading(true);

            try {
                // Get AI scores
                const scores = await getAIScores(essayText);

                // Store essay
                const essay = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    content: essayText.substring(0, 500) + '...',
                    scores: scores,
                    overallBand: scores.overall_band
                };
                gameState.essays.push(essay);

                // Calculate battle result
                const battleResult = calculateBattleResult(essay);

                // Update bosses
                gameState.currentBosses = calculateBosses(gameState.essays);

                // Log battle
                gameState.battleLog.unshift({
                    timestamp: new Date().toISOString(),
                    victory: battleResult.victory,
                    band: scores.overall_band,
                    improvements: battleResult.improvements,
                    regressions: battleResult.regressions
                });

                // Update stats
                if (battleResult.victory) {
                    gameState.victories++;
                    showVictoryEffect();
                } else {
                    gameState.defeats++;
                }

                saveGameState();
                updateUI();

                // Show result modal
                showResultModal(battleResult, scores);

                // Award XP via RPG system
                const xpAmount = battleResult.victory ? 60 + Math.floor(scores.overall_band * 5) : 30;
                if (typeof DevScribeRPG !== 'undefined') {
                    const result = DevScribeRPG.recordModuleAction('oracle', 'challenge', xpAmount);
                    if (result) DevScribeRPG.showXPNotification(result);
                }

                // Clear input
                document.getElementById('essay-input').value = '';
                document.getElementById('word-count').textContent = '0';

            } catch (error) {
                console.error(error);
                alert(window.i18n.t('analysisFailed') + error.message);
            } finally {
                showLoading(false);
            }
        }

        function calculateBattleResult(newEssay) {
            const prevEssays = gameState.essays.slice(0, -1);
            if (prevEssays.length === 0) {
                return { victory: true, improvements: ['firstSubmission'], regressions: [], isFirstBattle: true };
            }

            // Calculate previous averages
            const prevAvg = {};
            Object.keys(METRICS).forEach(metric => {
                const values = prevEssays.map(e => e.scores[metric]).filter(v => v !== undefined);
                prevAvg[metric] = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
            });

            const improvements = [];
            const regressions = [];

            Object.keys(METRICS).forEach(metric => {
                const diff = (newEssay.scores[metric] || 0) - prevAvg[metric];
                if (diff >= 0.05) {
                    improvements.push({ metric: METRICS[metric], diff: diff });
                    // Mark boss as damaged/defeated
                    if (diff >= 0.1) {
                        gameState.bossDefeated[metric] = true;
                    }
                } else if (diff <= -0.05) {
                    regressions.push({ metric: METRICS[metric], diff: diff });
                }
            });

            const victory = improvements.length >= regressions.length && improvements.length > 0;
            return { victory, improvements, regressions, isFirstBattle: false };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¨ UI RENDERING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function updateUI() {
            // Stats
            document.getElementById('stat-victories').textContent = gameState.victories;
            document.getElementById('stat-defeats').textContent = gameState.defeats;
            document.getElementById('stat-essays').textContent = gameState.essays.length;

            if (gameState.essays.length > 0) {
                const avgBand = gameState.essays.reduce((a, e) => a + e.overallBand, 0) / gameState.essays.length;
                document.getElementById('stat-avg-band').textContent = avgBand.toFixed(1);
            } else {
                document.getElementById('stat-avg-band').textContent = '-';
            }

            // Render bosses
            renderBosses();

            // Render battle log
            renderBattleLog();

            // RPG Status
            if (typeof DevScribeRPG !== 'undefined') {
                document.getElementById('rpg-status').innerHTML = DevScribeRPG.generateStatusCardHTML();
            }
        }

        // Helper to convert Metric Name or ID into correct translation key
        function normalizeMetricKey(key) {
            if (!key) return '';
            // If it matches ID pattern, return as is
            if (/^(ta_|cc_|lr_|gra_)/.test(key)) return key;

            const map = {
                'TA: Overview Clarity': 'ta_overview_clarity',
                'TA: Key Step Coverage': 'ta_step_coverage',
                'TA: Factual Accuracy': 'ta_logic_accuracy',
                'TA: Logic Accuracy': 'ta_logic_accuracy',
                'CC: Sequencing Markers': 'cc_sequencing_markers',
                'CC: Referencing': 'cc_referencing',
                'CC: Logical Paragraphing': 'cc_paragraphing',
                'LR: Process Verbs': 'lr_process_verbs',
                'LR: Topic Vocabulary': 'lr_topic_nouns',
                'LR: Paraphrasing Power': 'lr_paraphrasing',
                'LR: Precision & Conciseness': 'lr_conciseness',
                'GRA: Passive Voice Control': 'gra_passive_voice',
                'GRA: Passive Voice': 'gra_passive_voice',
                'GRA: Sentence Variety': 'gra_complex_structures',
                'GRA: Error-Free Sentences': 'gra_error_free_density'
            };
            return map[key] || key;
        }

        function renderBattleLog() {
            const container = document.getElementById('battle-log');
            if (gameState.battleLog.length === 0) {
                container.innerHTML = `<div class="text-center text-gray-500 py-8">${window.i18n.t('logEmptyState')}</div>`;
                return;
            }

            container.innerHTML = gameState.battleLog.slice(0, 20).map(log => {
                const time = new Date(log.timestamp).toLocaleString(window.i18n.currentLang === 'zh' ? 'zh-TW' : 'en-US');
                const statusClass = log.victory ? 'log-victory' : 'log-defeat';
                const icon = log.victory ? 'âœ…' : 'âŒ';
                const statusText = log.victory ? window.i18n.t('challengeSuccess') : window.i18n.t('challengeFail');

                return `
                    <div class="log-entry ${statusClass}">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="text-xl mr-2">${icon}</span>
                                <span class="font-semibold ${log.victory ? 'text-green-400' : 'text-red-400'}">
                                    ${statusText}
                                </span>
                                <span class="text-yellow-400 ml-2">Band ${log.band.toFixed(1)}</span>
                            </div>
                            <span class="text-xs text-gray-500">${time}</span>
                        </div>
                        ${log.improvements?.length > 0 ? `
                            <div class="text-xs text-green-400 mt-1">
                                â†‘ ${log.improvements.map(i => window.i18n.t(normalizeMetricKey(typeof i === 'object' ? i.metric : i))).join(', ')}
                            </div>
                        ` : ''}
                        ${log.regressions?.length > 0 ? `
                            <div class="text-xs text-red-400 mt-1">
                                â†“ ${log.regressions.map(r => window.i18n.t(normalizeMetricKey(r.metric))).join(', ')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        function showLoading(show) {
            document.getElementById('loading-overlay').classList.toggle('hidden', !show);
        }

        function showVictoryEffect() {
            const burst = document.createElement('div');
            burst.className = 'victory-burst';
            document.body.appendChild(burst);
            setTimeout(() => burst.remove(), 1000);
        }

        function showResultModal(battleResult, scores) {
            const modal = document.getElementById('result-modal');
            const icon = document.getElementById('result-icon');
            const title = document.getElementById('result-title');
            const details = document.getElementById('result-details');

            if (battleResult.isFirstBattle) {
                icon.textContent = 'ğŸ‰';
                title.innerHTML = window.i18n.t('firstBattleTitle', { band: scores.overall_band.toFixed(1) });
            } else if (battleResult.victory) {
                icon.textContent = 'âš”ï¸ğŸ†';
                title.innerHTML = window.i18n.t('victoryTitle');
            } else {
                icon.textContent = 'ğŸ’”';
                title.innerHTML = window.i18n.t('failTitle');
            }

            details.innerHTML = `
                <div class="bg-slate-800 rounded-lg p-4 mb-4">
                    <div class="text-center text-2xl font-bold text-yellow-400 mb-2">
                        ${window.i18n.t('modalBand', { band: scores.overall_band.toFixed(1) })}
                    </div>
                </div>
                ${battleResult.improvements.length > 0 ? `
                    <div class="bg-green-900/30 rounded-lg p-4 border border-green-500/30">
                        <div class="font-semibold text-green-400 mb-2">${window.i18n.t('modalImprovements')}</div>
                        <ul class="text-sm text-gray-300 space-y-1">
                    ${battleResult.improvements.map(i => {
                const raw = typeof i === 'object' ? i.metric : i;
                const mKey = normalizeMetricKey(raw);
                const label = window.i18n.t(mKey);
                const diffText = typeof i === 'object' ? ` (+${(i.diff * 100).toFixed(0)}%)` : '';
                return `<li class="group relative cursor-help border-b border-dotted border-gray-600" onclick="alert(window.i18n.t('${mKey}_desc'))">
                            âœ“ ${label}${diffText}
                            <div class="hidden group-hover:block absolute left-1/2 bottom-full -translate-x-1/2 mb-2 w-64 bg-slate-900 border border-slate-700 p-3 rounded text-xs shadow-2xl z-50 pointer-events-none">
                                ${window.i18n.t(mKey + '_desc')}
                            </div>
                        </li>`;
            }).join('')}
                </ul>
            </div>
        ` : ''}
        ${battleResult.regressions.length > 0 ? `
            <div class="bg-red-900/30 rounded-lg p-4 border border-red-500/30 mt-3">
                <div class="font-semibold text-red-400 mb-2">${window.i18n.t('modalRegressions')}</div>
                <ul class="text-sm text-gray-300 space-y-1">
                    ${battleResult.regressions.map(r => {
                const raw = r.metric;
                const mKey = normalizeMetricKey(raw);
                const label = window.i18n.t(mKey);
                const diffText = ` (${(r.diff * 100).toFixed(0)}%)`;
                return `<li class="group relative cursor-help border-b border-dotted border-gray-700" onclick="alert(window.i18n.t('${mKey}_desc'))">
                            âœ— ${label}${diffText}
                            <div class="hidden group-hover:block absolute left-1/2 bottom-full -translate-x-1/2 mb-2 w-64 bg-slate-900 border border-slate-700 p-3 rounded text-xs shadow-2xl z-50 pointer-events-none">
                                ${window.i18n.t(mKey + '_desc')}
                            </div>
                        </li>`;
            }).join('')}
                </ul>
            </div>
        ` : ''}
            `;

            modal.classList.remove('hidden');
        }

        function closeResultModal() {
            document.getElementById('result-modal').classList.add('hidden');
        }

        function showBossDefeatedEffect(bossName) {
            const overlay = document.getElementById('boss-defeated-overlay');
            const nameEl = document.getElementById('defeated-boss-name');

            nameEl.textContent = window.i18n.t(normalizeMetricKey(bossName));
            overlay.classList.remove('hidden');
            // Trigger reflow
            void overlay.offsetWidth;
            overlay.classList.add('active');

            // Play sound? (Optional)

            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                }, 500);
            }, 3500);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸš€ INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const API_BASE_URL = '/api/arena';
        let useBackendMode = true; // é è¨­ä½¿ç”¨å¾Œç«¯æ¨¡å¼
        let activeCharts = {}; // Store Chart.js instances

        function renderCharts(data) {
            Chart.defaults.color = '#94a3b8';
            Chart.defaults.font.family = 'Inter';

            // 1. Radar Chart
            const radarCtx = document.getElementById('radarChart').getContext('2d');
            if (activeCharts.radar) activeCharts.radar.destroy();

            activeCharts.radar = new Chart(radarCtx, {
                type: 'radar',
                data: {
                    labels: data.radar.categories.map(label => {
                        // Attempt to find translation for the label if it's a metric key
                        // Backend might send raw keys or names. We try to translate keys.
                        const key = Object.keys(METRICS).find(k => METRICS[k] === label) || label;
                        return window.i18n.t(key);
                    }),
                    datasets: [{
                        label: window.i18n.t('radarLabel'),
                        data: data.radar.values,
                        backgroundColor: 'rgba(139, 92, 246, 0.2)', // Indigo 500
                        borderColor: '#8b5cf6',
                        pointBackgroundColor: '#fff',
                        pointBorderColor: '#8b5cf6',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#8b5cf6'
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    layout: {
                        padding: 10
                    },
                    scales: {
                        r: {
                            angleLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            pointLabels: {
                                color: '#cbd5e1',
                                font: { size: 11 },
                                // Split long labels into multiple lines to avoid truncation
                                callback: function (label) {
                                    if (label.includes('&')) return label.split(' & ');
                                    if (label.includes(' ')) return label.split(' ');
                                    return label;
                                }
                            },
                            ticks: { display: false, backdropColor: 'transparent' },
                            min: 0,
                            max: 1
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // 2. Trend Chart
            const trendCtx = document.getElementById('trendChart').getContext('2d');
            if (activeCharts.trend) activeCharts.trend.destroy();

            activeCharts.trend = new Chart(trendCtx, {
                type: 'line',
                data: {
                    labels: data.trend.labels,
                    datasets: [{
                        label: window.i18n.t('trendLabel'),
                        data: data.trend.data,
                        borderColor: '#22d3ee', // Cyan 400
                        backgroundColor: 'rgba(34, 211, 238, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true,
                        pointBackgroundColor: '#22d3ee'
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            beginAtZero: true,
                            max: 9,
                            title: { display: true, text: window.i18n.t('trendAxisY'), color: '#94a3b8' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: {
                                maxTicksLimit: 8, // Prevent overcrowding
                                maxRotation: 0,
                                autoSkip: true
                            }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // 3. RCA Bar Chart (with Comparison)
            const rcaCtx = document.getElementById('rcaChart').getContext('2d');
            if (activeCharts.rca) activeCharts.rca.destroy();

            // Prepare RCA data (Sort descending)
            const rcaItems = data.rca || [];
            rcaItems.sort((a, b) => b.Bottleneck_Index - a.Bottleneck_Index);

            const rcaLabels = rcaItems.map(item => window.i18n.t(item.Metric));
            const currentValues = rcaItems.map(item => item.Bottleneck_Index);
            const prevValues = rcaItems.map(item => item.Prev_Bottleneck_Index || 0);

            // Color logic: Current bars
            const barColors = currentValues.map((v, i) => i < 3 ? '#f43f5e' : '#3b82f6');

            // Custom Plugin to draw arrows
            const arrowPlugin = {
                id: 'arrowPlugin',
                afterDatasetsDraw(chart, args, options) {
                    const ctx = chart.ctx;
                    const metaCurrent = chart.getDatasetMeta(0);
                    const metaPrev = chart.getDatasetMeta(1);

                    if (!metaCurrent.data.length || !metaPrev.data.length) return;

                    ctx.save();

                    metaCurrent.data.forEach((currBar, i) => {
                        const prevPoint = metaPrev.data[i];
                        if (!prevPoint) return;

                        const startX = prevPoint.x;
                        const endX = currBar.x;
                        const y = currBar.y;

                        // Check if we have valid previous data
                        if (prevValues[i] <= 0.001) return; // Skip if no prev data

                        const diff = endX - startX;

                        // Hybrid Logic: Score Significance vs Visual Aesthetics
                        const item = rcaItems[i];
                        const scoreDiff = Math.abs(item.Bottleneck_Index - (item.Prev_Bottleneck_Index || 0));

                        // Rule 1: Always show if score change is significant (> 0.01)
                        const isSignificant = scoreDiff >= 0.01;

                        // Rule 2: If change is minor, ensure it's visually distinct (> 3px)
                        const isVisuallyDistinct = Math.abs(diff) >= 3;

                        if (!isSignificant && !isVisuallyDistinct) return;

                        // Determine color (Bottleneck DECREASE = Improvement = Green)
                        // Note: X axis increases to right.
                        // If End < Start (Left shift) -> Bottleneck Reduced -> Green
                        // If End > Start (Right shift) -> Bottleneck Increased -> Red
                        const isImprovement = endX < startX;

                        // High Contrast Colors:
                        // Improvement: Bright Green (#34d399) - Visible on dark bg
                        // Worsening: Bright Yellow (#facc15) - High contrast against Red bars
                        const color = isImprovement ? '#34d399' : '#facc15';

                        // Draw Arrow Line
                        ctx.beginPath();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = color;
                        ctx.moveTo(startX, y);
                        ctx.lineTo(endX, y);
                        ctx.stroke();

                        // Draw Arrow Head at End X
                        ctx.beginPath();
                        ctx.fillStyle = color;
                        const headSize = 5;
                        if (isImprovement) {
                            // Pointing Left
                            ctx.moveTo(endX, y);
                            ctx.lineTo(endX + headSize, y - headSize);
                            ctx.lineTo(endX + headSize, y + headSize);
                        } else {
                            // Pointing Right
                            ctx.moveTo(endX, y);
                            ctx.lineTo(endX - headSize, y - headSize);
                            ctx.lineTo(endX - headSize, y + headSize);
                        }
                        ctx.fill();

                        // Draw Dot at Start X (Previous)
                        ctx.beginPath();
                        ctx.fillStyle = '#94a3b8'; // Slate 400
                        ctx.arc(startX, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    ctx.restore();
                }
            };

            activeCharts.rca = new Chart(rcaCtx, {
                type: 'bar',
                data: {
                    labels: rcaLabels,
                    datasets: [
                        {
                            label: window.i18n.t('currImpact'),
                            data: currentValues,
                            backgroundColor: barColors,
                            borderRadius: 4,
                            order: 2
                        },
                        {
                            label: window.i18n.t('prevImpact'),
                            data: prevValues,
                            type: 'scatter', // Render as points so we can access coordinates
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            pointRadius: 0, // Hiding default points, drawing custom in plugin
                            order: 1
                        }
                    ]
                },
                options: {
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: { display: true, text: window.i18n.t('rcaAxisX'), color: '#94a3b8' },
                            beginAtZero: true
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#cbd5e1' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    if (context.datasetIndex === 1) return null; // Hide prev point tooltip
                                    const item = rcaItems[context.dataIndex];
                                    const curr = item.Bottleneck_Index.toFixed(3);
                                    const prev = item.Prev_Bottleneck_Index > 0 ? item.Prev_Bottleneck_Index.toFixed(3) : 'N/A';
                                    let diffText = '';
                                    if (item.Prev_Bottleneck_Index > 0) {
                                        const diff = item.Bottleneck_Index - item.Prev_Bottleneck_Index;
                                        if (diff < 0) diffText = ` (${window.i18n.t('improvedBy', { val: Math.abs(diff).toFixed(3) })})`;
                                        else diffText = ` (${window.i18n.t('worsenedBy', { val: diff.toFixed(3) })})`;
                                    }
                                    return `${window.i18n.t('scoreLabel')}: ${curr} | ${window.i18n.t('prevLabel')}: ${prev}${diffText}`;
                                }
                            }
                        }
                    }
                },
                plugins: [arrowPlugin]
            });
        }

        // Check backend health
        async function checkBackendHealth() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });
                if (response.ok) {
                    document.getElementById('backend-status').textContent = window.i18n.t('backendConnected');
                    document.getElementById('backend-status').classList.replace('text-gray-500', 'text-green-400');
                    document.getElementById('backend-status').classList.replace('text-red-400', 'text-green-400');
                    return true;
                }
            } catch (e) {
                document.getElementById('backend-status').textContent = window.i18n.t('backendDisconnected');
                document.getElementById('backend-status').classList.replace('text-green-400', 'text-red-400');
                document.getElementById('backend-status').classList.replace('text-gray-500', 'text-red-400');
            }
            return false;
        }

        // Render Analysis Result (Charts & Recommendations)
        function renderAnalysisResult(result) {
            if (!result) return;

            // 1. Display charts
            const chartSection = document.getElementById('chart-section');
            if (result.chart_data) {
                document.getElementById('charts-container').classList.remove('hidden');
                document.getElementById('charts-legacy').classList.add('hidden');
                chartSection.classList.remove('hidden');
                requestAnimationFrame(() => renderCharts(result.chart_data));
            } else if (result.chart_image) {
                document.getElementById('charts-container').classList.add('hidden');
                const legacyDiv = document.getElementById('charts-legacy');
                const chartImg = document.getElementById('rca-chart');
                legacyDiv.classList.remove('hidden');
                chartImg.src = `data:image/png;base64,${result.chart_image}`;
                chartSection.classList.remove('hidden');
            }

            // 2. Display localized recommendations
            if (result.recommendations) {
                const recSection = document.getElementById('recommendations-section');
                const recContent = document.getElementById('recommendations-content');

                let displayHtml = result.recommendations;

                // Check if we have dual-language content
                const delimiter = "===ENGLISH_VERSION_START===";
                if (result.recommendations.includes(delimiter)) {
                    const parts = result.recommendations.split(delimiter);
                    const zhVersion = parts[0].trim();
                    const enVersion = (parts[1] || '').trim();

                    displayHtml = (window.i18n.currentLang === 'zh') ? zhVersion : enVersion;
                }

                recContent.innerHTML = displayHtml.replace(/\n/g, '<br>');
                recSection.classList.remove('hidden');
            }
        }

        // Full RCA analysis via backend
        async function startChallengeWithBackend(essayText) {
            const loadingText = document.getElementById('loading-text');
            const loadingSubtext = document.getElementById('loading-subtext');

            loadingText.textContent = window.i18n.t('loadingBackend');
            loadingSubtext.textContent = window.i18n.t('loadingSubtextBackend');

            const response = await fetch(`${API_BASE_URL}/api/full-rca`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    essays: gameState.essays,
                    new_essay: essayText,
                    provider: 'kimi'
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Backend API Error');
            }

            // Just return the result, let the caller handle rendering and saving
            return await response.json();
        }

        async function startChallengeUnified() {
            const essayText = document.getElementById('essay-input').value.trim();
            if (!essayText || essayText.length < 50) {
                alert(window.i18n.t('alertShortEssay'));
                return;
            }

            // æª¢æŸ¥å¾Œç«¯æ˜¯å¦åœ¨ç·š
            const isConnected = await checkBackendHealth();
            if (!isConnected) {
                alert(window.i18n.t('alertBackendOffline'));
                return;
            }

            showLoading(true);

            try {
                // ç›´æ¥é€²è¡Œå¾Œç«¯ RCA åˆ†æ
                const result = await startChallengeWithBackend(essayText);

                // Save analysis result to state for persistence
                gameState.lastAnalysis = {
                    chart_data: result.chart_data,
                    chart_image: result.chart_image,
                    recommendations: result.recommendations,
                    timestamp: new Date().toISOString()
                };

                // Render immediately
                renderAnalysisResult(result);

                const scores = result.new_scores;
                const battleResult = result.battle_result;

                // æ¨™æº–åŒ–æˆ°é¬¥çµæœ (ç›¸å®¹å‰ç«¯é¡¯ç¤ºæ ¼å¼)
                if (battleResult.is_first_battle) {
                    battleResult.improvements = ['firstSubmission'];
                    battleResult.regressions = [];
                }
                battleResult.isFirstBattle = battleResult.is_first_battle;

                // å„²å­˜çµæœ
                const essayEntry = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    content: essayText.substring(0, 500) + '...',
                    scores: scores,
                    overallBand: scores.overall_band
                };
                gameState.essays.push(essayEntry);

                // æ›´æ–° BOSS
                gameState.currentBosses = calculateBosses(gameState.essays);

                // è¨˜éŒ„æˆ°é¬¥
                gameState.battleLog.unshift({
                    timestamp: new Date().toISOString(),
                    victory: battleResult.victory,
                    band: scores.overall_band,
                    improvements: battleResult.improvements,
                    regressions: battleResult.regressions
                });

                // æ›´æ–°çµ±è¨ˆ
                if (battleResult.victory) {
                    gameState.victories++;
                    showVictoryEffect();
                } else {
                    gameState.defeats++;
                }

                saveGameState();
                updateUI();
                showResultModal(battleResult, scores);

                // 2026-01-28: CHECK FOR BOSS DEFEAT (Dropped out of Top 3)
                // We compare the OLD Top 1 Boss to the NEW Top Bosses
                // If the Old Top 1 is NOT in the New Top 3, it's considered "Defeated" (Bottleneck removed)

                // Get the OLD top boss from the logic *before* this update (we can roughly infer or should have stored it)
                // Since we already updated gameState.currentBosses, this is tricky.
                // ideally we capture old bosses before update.
                // Let's rely on the previous analysis if available or just check if our biggest weakness improved significantly?

                // Better approach: We captured `gameState.currentBosses` BEFORE `calculateBosses` was called again via `startBosses`.
                // Wait, I updated gameState.currentBosses in line 1720.
                // Let's modify the flow to capture it before.

                // Correction: In future optimization, pass `oldBosses` to this function or capture at start.
                // For now, let's assume if we have a "significant improvement" on a metric that WAS a boss.

                // Refined Logic (Simplified for this iteration):
                // If the BOTTLE_NECK_INDEX of the Top 1 Boss dropped significantly (e.g. > 0.05), show effect.
                // Or simply: If we got a Victory, show a mini effect.
                // But user wants "Defeated!" when dropping out of Top 3.

                // Let's implement this properly in the NEXT refactor by capturing old state. 
                // For now, I'll just use the `battleResult.improvements` to see if a major boss improved.
                if (gameState.lastAnalysis && gameState.lastAnalysis.chart_data && gameState.lastAnalysis.chart_data.rca) {
                    // Check if any improvement was a top boss
                    // This is complex to do purely here without prev state refactor. 
                    // I will execute `showBossDefeatedEffect` if we have a VICTORY and a High Band (> 7.0) as a proxy for now, 
                    // OR if we can find the metric in improvements.

                    const rca = gameState.lastAnalysis.chart_data.rca;
                    // top bottleneck
                    if (rca.length > 0) {
                        const topMetric = rca[0].Metric;
                        // If this metric improved significantly
                        const imp = battleResult.improvements.find(i => (typeof i === 'object' ? i.metric : i) === topMetric);
                        if (battleResult.victory && scores.overall_band >= 7.0) {
                            setTimeout(() => showBossDefeatedEffect(topMetric), 1000);
                        }
                    }
                }

                // Quest Empire é€£å‹• - ç™¼æ”¾ XP å’Œä»£å¹£
                const xpAmount = battleResult.victory ? 60 + Math.floor(scores.overall_band * 5) : 30;
                const tokenAmount = battleResult.victory ? 15 + Math.floor(scores.overall_band * 2) : 5;

                if (typeof DevScribeRPG !== 'undefined') {
                    try {
                        // æ›´æ–° Quest Empire ç‹€æ…‹
                        const state = DevScribeRPG.getState();
                        const oldLevel = state.level;

                        state.totalXP += xpAmount;
                        state.tokens += tokenAmount;
                        state.stats = state.stats || {};
                        state.stats.totalTokensEarned = (state.stats.totalTokensEarned || 0) + tokenAmount;

                        // æ›´æ–°é€£çºŒå¤©æ•¸
                        const today = new Date().toISOString().split('T')[0];
                        if (state.lastLoginDate !== today) {
                            const yesterday = new Date();
                            yesterday.setDate(yesterday.getDate() - 1);
                            const yesterdayStr = yesterday.toISOString().split('T')[0];
                            if (state.lastLoginDate === yesterdayStr) {
                                state.currentStreak = (state.currentStreak || 0) + 1;
                            } else {
                                state.currentStreak = 1;
                            }
                            state.maxStreak = Math.max(state.maxStreak || 0, state.currentStreak);
                            state.lastLoginDate = today;
                        }

                        // è¨ˆç®—æ–°ç­‰ç´š
                        const newRank = DevScribeRPG.calculateLevel(state.totalXP);
                        state.level = newRank.level;

                        // å„²å­˜ç‹€æ…‹
                        localStorage.setItem('quest_empire_state', JSON.stringify(state));

                        // é¡¯ç¤ºé€šçŸ¥
                        DevScribeRPG.showNotification(
                            battleResult.victory ? window.i18n.t('notifyChallengeSuccess') : window.i18n.t('notifyChallengeCompleted'),
                            `+${xpAmount} XP, +${tokenAmount} ğŸ’°`,
                            battleResult.victory ? 'success' : 'info',
                            battleResult.victory ? 'ğŸ†' : 'âš”ï¸'
                        );

                        // å‡ç´šé€šçŸ¥
                        if (newRank.level > oldLevel) {
                            setTimeout(() => {
                                // Translate rank title if possible
                                const rankKey = 'rpgRank' + newRank.level;
                                const translatedTitle = window.i18n.currentLang === 'en' && window.i18n.translations.en[rankKey]
                                    ? window.i18n.translations.en[rankKey]
                                    : (window.i18n.translations.zh[rankKey] || newRank.title);

                                DevScribeRPG.showNotification(
                                    window.i18n.t('notifyLevelUp'),
                                    window.i18n.t('notifyLevelTitle', { level: newRank.level, title: translatedTitle }),
                                    'success',
                                    'ğŸ‰'
                                );
                            }, 2000);
                        }
                    } catch (e) {
                        console.error('[Arena] Quest Empire integration error:', e);
                    }
                }

                document.getElementById('essay-input').value = '';
                document.getElementById('word-count').textContent = '0';

            } catch (error) {
                console.error(error);
                alert(window.i18n.t('analysisFailed') + error.message);
            } finally {
                showLoading(false);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Event listeners
            document.getElementById('challenge-btn').addEventListener('click', startChallengeUnified);
            document.getElementById('essay-input').addEventListener('input', (e) => {
                document.getElementById('word-count').textContent = e.target.value.trim().length;
            });

            // Calculate bosses if we have essays
            if (gameState.essays.length > 0) {
                gameState.currentBosses = calculateBosses(gameState.essays);
            }

            // Initial backend health check
            checkBackendHealth();
            // æ¯ 10 ç§’è‡ªå‹•æª¢æŸ¥ä¸€æ¬¡é€£ç·š
            setInterval(checkBackendHealth, 10000);

            updateUI();
            console.log('âš”ï¸ Challenger Arena initialized in Backend-Only mode!');

            // Restore last analysis session if available
            if (gameState.lastAnalysis) {
                renderAnalysisResult(gameState.lastAnalysis);
            }

            // ç›£è½ RPG é‡ç½®äº‹ä»¶
            if (typeof DevScribeRPG !== 'undefined') {
                DevScribeRPG.addEventListener('reset', () => {
                    localStorage.removeItem(STORAGE_KEY);
                    gameState = loadGameState();
                    updateUI();
                });
            }
        });
    </script>
</body>

</html>